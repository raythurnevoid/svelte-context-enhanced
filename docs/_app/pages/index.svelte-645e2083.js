import{S as D,i as J,s as K,w as p,x as c,y as _,q as g,o as w,B as b,k as x,e as R,t as h,m as d,c as q,a as L,h as v,d as $,g as f,U as F}from"../chunks/vendor-32dd28f6.js";import{g as N,M as O,P as Q,a as V,S as j,C as z,F as W}from"../chunks/CopyButton-c47b43e8.js";/* empty css                                                         */import{b as X}from"../chunks/paths-396f020f.js";import"../chunks/preload-helper-413b0d67.js";function Y(r){let t;return{c(){t=h("Svelte Typed Context")},l(n){t=v(n,"Svelte Typed Context")},m(n,s){f(n,t,s)},d(n){n&&$(t)}}}function Z(r){let t;return{c(){t=h("How to use")},l(n){t=v(n,"How to use")},m(n,s){f(n,t,s)},d(n){n&&$(t)}}}function ee(r){let t;return{c(){t=h("Installation")},l(n){t=v(n,"Installation")},m(n,s){f(n,t,s)},d(n){n&&$(t)}}}function te(r){let t,n,s,a,l,H,I,C,i,U,m,y,u,B,S,P,T,E;return t=new V({props:{$$slots:{default:[Y]},$$scope:{ctx:r}}}),i=new j({props:{$$slots:{default:[Z]},$$scope:{ctx:r}}}),m=new z({props:{lang:"ts",source:r[0]}}),u=new j({props:{$$slots:{default:[ee]},$$scope:{ctx:r}}}),S=new z({props:{lang:"shell",source:"npm i @raythurnevoid/svelte-context-enhanced"}}),T=new W({props:{next:{label:"BASIC USAGE",href:`${X}/basic`}}}),{c(){p(t.$$.fragment),n=x(),s=R("p"),a=h(`The problem with Svelte's out of the box context system is the missing of\r
			typings support for values. `),l=R("br"),H=R("br"),I=h(` This library wants to address this\r
			feature.`),C=x(),p(i.$$.fragment),U=x(),p(m.$$.fragment),y=x(),p(u.$$.fragment),B=x(),p(S.$$.fragment),P=x(),p(T.$$.fragment)},l(e){c(t.$$.fragment,e),n=d(e),s=q(e,"P",{});var o=L(s);a=v(o,`The problem with Svelte's out of the box context system is the missing of\r
			typings support for values. `),l=q(o,"BR",{}),H=q(o,"BR",{}),I=v(o,` This library wants to address this\r
			feature.`),o.forEach($),C=d(e),c(i.$$.fragment,e),U=d(e),c(m.$$.fragment,e),y=d(e),c(u.$$.fragment,e),B=d(e),c(S.$$.fragment,e),P=d(e),c(T.$$.fragment,e)},m(e,o){_(t,e,o),f(e,n,o),f(e,s,o),F(s,a),F(s,l),F(s,H),F(s,I),f(e,C,o),_(i,e,o),f(e,U,o),_(m,e,o),f(e,y,o),_(u,e,o),f(e,B,o),_(S,e,o),f(e,P,o),_(T,e,o),E=!0},p(e,o){const A={};o&2&&(A.$$scope={dirty:o,ctx:e}),t.$set(A);const M={};o&2&&(M.$$scope={dirty:o,ctx:e}),i.$set(M);const k={};o&1&&(k.source=e[0]),m.$set(k);const G={};o&2&&(G.$$scope={dirty:o,ctx:e}),u.$set(G)},i(e){E||(g(t.$$.fragment,e),g(i.$$.fragment,e),g(m.$$.fragment,e),g(u.$$.fragment,e),g(S.$$.fragment,e),g(T.$$.fragment,e),E=!0)},o(e){w(t.$$.fragment,e),w(i.$$.fragment,e),w(m.$$.fragment,e),w(u.$$.fragment,e),w(S.$$.fragment,e),w(T.$$.fragment,e),E=!1},d(e){b(t,e),e&&$(n),e&&$(s),e&&$(C),b(i,e),e&&$(U),b(m,e),e&&$(y),b(u,e),e&&$(B),b(S,e),e&&$(P),b(T,e)}}}function se(r){let t,n;return t=new Q({props:{$$slots:{default:[te]},$$scope:{ctx:r}}}),{c(){p(t.$$.fragment)},l(s){c(t.$$.fragment,s)},m(s,a){_(t,s,a),n=!0},p(s,a){const l={};a&3&&(l.$$scope={dirty:a,ctx:s}),t.$set(l)},i(s){n||(g(t.$$.fragment,s),n=!0)},o(s){w(t.$$.fragment,s),n=!1},d(s){b(t,s)}}}function ne(r){let t,n;return t=new O({props:{$$slots:{default:[se]},$$scope:{ctx:r}}}),{c(){p(t.$$.fragment)},l(s){c(t.$$.fragment,s)},m(s,a){_(t,s,a),n=!0},p(s,[a]){const l={};a&3&&(l.$$scope={dirty:a,ctx:s}),t.$set(l)},i(s){n||(g(t.$$.fragment,s),n=!0)},o(s){w(t.$$.fragment,s),n=!1},d(s){b(t,s)}}}const ie=async function({fetch:r}){async function t(){return await N(r,"src/lib/components/examples/basic/BasicExampleContext.ts")}return{props:{howToUseSource:await t()}}};function oe(r,t,n){let{howToUseSource:s}=t;return r.$$set=a=>{"howToUseSource"in a&&n(0,s=a.howToUseSource)},[s]}class me extends D{constructor(t){super();J(this,t,oe,ne,K,{howToUseSource:0})}}export{me as default,ie as load};
