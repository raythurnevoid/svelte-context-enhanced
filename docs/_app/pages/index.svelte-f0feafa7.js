import{S as j,i as z,V as D,w as p,x as c,y as g,q as _,o as w,B as b,k as x,e as R,t as h,m as d,c as q,a as J,h as v,d as $,g as f,W as F}from"../chunks/index-565a60eb.js";import{g as K,M as L,P as N,a as O,S as V,C as W,F as Q}from"../chunks/CopyButton-06291b5b.js";import"../chunks/ModulePage.svelte_svelte_type_style_lang-b472ed71.js";import{b as X}from"../chunks/paths-396f020f.js";import"../chunks/preload-helper-413b0d67.js";function Y(r){let t;return{c(){t=h("Svelte Typed Context")},l(n){t=v(n,"Svelte Typed Context")},m(n,s){f(n,t,s)},d(n){n&&$(t)}}}function Z(r){let t;return{c(){t=h("How to use")},l(n){t=v(n,"How to use")},m(n,s){f(n,t,s)},d(n){n&&$(t)}}}function ee(r){let t;return{c(){t=h("Installation")},l(n){t=v(n,"Installation")},m(n,s){f(n,t,s)},d(n){n&&$(t)}}}function te(r){let t,n,s,a,l,H,I,C,i,y,m,U,u,B,S,P,T,E;return t=new O({props:{$$slots:{default:[Y]},$$scope:{ctx:r}}}),i=new V({props:{$$slots:{default:[Z]},$$scope:{ctx:r}}}),m=new W({props:{lang:"ts",source:r[0]}}),u=new V({props:{$$slots:{default:[ee]},$$scope:{ctx:r}}}),S=new W({props:{lang:"shell",source:"npm i @raythurnevoid/svelte-context-enhanced"}}),T=new Q({props:{next:{label:"BASIC USAGE",href:`${X}/basic`}}}),{c(){p(t.$$.fragment),n=x(),s=R("p"),a=h(`The problem with Svelte's out of the box context system is the missing of\r
			typings support for values. `),l=R("br"),H=R("br"),I=h(` This library wants to address this\r
			feature.`),C=x(),p(i.$$.fragment),y=x(),p(m.$$.fragment),U=x(),p(u.$$.fragment),B=x(),p(S.$$.fragment),P=x(),p(T.$$.fragment)},l(e){c(t.$$.fragment,e),n=d(e),s=q(e,"P",{});var o=J(s);a=v(o,`The problem with Svelte's out of the box context system is the missing of\r
			typings support for values. `),l=q(o,"BR",{}),H=q(o,"BR",{}),I=v(o,` This library wants to address this\r
			feature.`),o.forEach($),C=d(e),c(i.$$.fragment,e),y=d(e),c(m.$$.fragment,e),U=d(e),c(u.$$.fragment,e),B=d(e),c(S.$$.fragment,e),P=d(e),c(T.$$.fragment,e)},m(e,o){g(t,e,o),f(e,n,o),f(e,s,o),F(s,a),F(s,l),F(s,H),F(s,I),f(e,C,o),g(i,e,o),f(e,y,o),g(m,e,o),f(e,U,o),g(u,e,o),f(e,B,o),g(S,e,o),f(e,P,o),g(T,e,o),E=!0},p(e,o){const A={};o&2&&(A.$$scope={dirty:o,ctx:e}),t.$set(A);const M={};o&2&&(M.$$scope={dirty:o,ctx:e}),i.$set(M);const k={};o&1&&(k.source=e[0]),m.$set(k);const G={};o&2&&(G.$$scope={dirty:o,ctx:e}),u.$set(G)},i(e){E||(_(t.$$.fragment,e),_(i.$$.fragment,e),_(m.$$.fragment,e),_(u.$$.fragment,e),_(S.$$.fragment,e),_(T.$$.fragment,e),E=!0)},o(e){w(t.$$.fragment,e),w(i.$$.fragment,e),w(m.$$.fragment,e),w(u.$$.fragment,e),w(S.$$.fragment,e),w(T.$$.fragment,e),E=!1},d(e){b(t,e),e&&$(n),e&&$(s),e&&$(C),b(i,e),e&&$(y),b(m,e),e&&$(U),b(u,e),e&&$(B),b(S,e),e&&$(P),b(T,e)}}}function se(r){let t,n;return t=new N({props:{$$slots:{default:[te]},$$scope:{ctx:r}}}),{c(){p(t.$$.fragment)},l(s){c(t.$$.fragment,s)},m(s,a){g(t,s,a),n=!0},p(s,a){const l={};a&3&&(l.$$scope={dirty:a,ctx:s}),t.$set(l)},i(s){n||(_(t.$$.fragment,s),n=!0)},o(s){w(t.$$.fragment,s),n=!1},d(s){b(t,s)}}}function ne(r){let t,n;return t=new L({props:{$$slots:{default:[se]},$$scope:{ctx:r}}}),{c(){p(t.$$.fragment)},l(s){c(t.$$.fragment,s)},m(s,a){g(t,s,a),n=!0},p(s,[a]){const l={};a&3&&(l.$$scope={dirty:a,ctx:s}),t.$set(l)},i(s){n||(_(t.$$.fragment,s),n=!0)},o(s){w(t.$$.fragment,s),n=!1},d(s){b(t,s)}}}const ie=async function({fetch:r}){async function t(){return await K(r,"src/lib/components/examples/basic/BasicExampleContext.ts")}return{props:{howToUseSource:await t()}}};function oe(r,t,n){let{howToUseSource:s}=t;return r.$$set=a=>{"howToUseSource"in a&&n(0,s=a.howToUseSource)},[s]}class me extends j{constructor(t){super(),z(this,t,oe,ne,D,{howToUseSource:0})}}export{me as default,ie as load};
